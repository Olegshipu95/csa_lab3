# Лабораторная работа №3. Транслятор и модель процессора

* P33311. Шипулин Олег Игоеревич
* ```forth | stack | harv | hw | instr | binary | trap | mem | pstr | prob5 | spi```


## Язык программирования

```text

<процедура> →   ": " <название процедуры> <программа> " ;"

<программа> →   <пусто> | <слово> | <программа> " " <программа> | <условный оператор> |
                <оператор цикла do loop> | <оператор цикла begin until> <объявление переменной>
                
<объявление переменной> → "variable " <переменная> ["allot " <целочисленный литерал>] 

<условный оператор> → if <программа> [else <программаа>] then  

<оператор цикла do loop> → do <программа> loop  

<оператор цикла begin until> → begin <программа> until  

<слово> →   <целочисленный литерал> | <математический оператор> | <отображение строки> | <название процедуры> |
            "mod" | "drop" | "swap" | "over" | "dup" | "read" | "omit" | <переменная> | "@" | "!" | "ei" | "di"

<математический оператор> → "+" | "-" | "*" | "/" | "=" | "<" | ">" 

<отображение строки> → "." <строковый литерал>

```

Код выполняется последовательно за исключением процедур.
Вызов процедуры осуществляется при указании в программе её названия. Комментарии не предусмотрены.

Ниже описаны основные стековые операции в виде (stack_before -- stack_after) с некоторыми пояснениями.

* ```+``` - (n1 n2 -- n3)
* ```-``` - (n1 n2 -- n3)
* ```*``` - (n1 n2 -- n3)
* ```/``` - (n1 n2 -- n3)
* ```=``` - (n1 n2 -- n3) n3 = 1 if n1 == n2 n3 = 0 if n1 != n2
* ```>``` - (n1 n2 -- n3) n3 = 1 if n1 > n2 n3 = 0 if n1 <= n2
* ```<``` - (n1 n2 -- n3) n3 = 1 if n1 < n2 n3 = 0 if n1 >= n2
* ```mod``` - (n1 n2 -- n3)
* ```drop``` - (n1 -- )
* ```swap``` - (n1 n2 -- n2 n1)
* ```over``` - (n1 n2 -- n1 n2 n1)
* ```dup``` - (n1 -- n1 n1) -
* ```key``` - (n1 -- n2) - ввод c порта n1
* ```omit``` - (n1 n2 -- ) - вывести ASCII символ с кодом n1 в IO порт n2
* ```read``` - (n1 -- n2) - прочитать значение с порта n1 и положить на стек
* ```!``` - (n1 n2 -- ) - записать значение n1 в ячейку памяти n2
* ```@``` - (n1 -- n2) - прочитать значение из ячейки памяти n1 и положить его на стек
* ```ei``` - ( -- ) - включить прерывания
* ```di``` - ( -- ) - отключить прерывания

Условный оператор ```if``` выполняется в зависимости от истинности значения на вершине стека.
Истинным значением является любое целое числа за исключением 0. Ложным значением является 0.

Оператор цикла ```do loop``` выполняет ```K``` итераций в зависимости от двух значений на вершине стека (n1 n2);
```K = n1 - n2```. Внутри конструкции ```do loop``` возможно использовать
переменную ```i```, ```i = n2 + <номер итерации>```.
Аналогично конструкции ```for (i = n2; i < n1; i++) {}``` в алгоритмическом языке программирования

Оператор цикла ```begin until``` выполняет итерации до момента, когда на вершине стека
по достижению конструкции until не будет лежать истинное значение (отличное от нуля).

Оператор объявления переменной ```variable``` создаёт переменную и сопоставляет ей
определенную ячейку памяти, взаимодействовать с которой возможно при помощи ```!``` и ```@```.
В случае добавления ключевого слова ```allot``` выделяется непрерывный участок памяти с фиксированным
в программе размером.

Комментарии не предусмотрены.

Используемые литералы:

* строковые литералы - имеют вид " <строка>", используются для экранизации текста после оператора ```.```
* целочисленные литералы - являются полноценным словом в программе и необходимы для того, чтобы положить конкретное
  значение на вершину стека, диапазон значений - $[-2^{31}, 2^{31} - 1]$

## Организация памяти

- Память данных и команд раздельна
- Размер машинного слова данных -- 32 бита
- Размер машинного слова команд -- 32 бита 
- Программисту в явном виде доступен исключительно стек данных и память, зарезервированная
  под переменные
- Память данных и команд выделяется статически при запуске модели
- Доступен один вид прерываний - его обработчик лежит по адресу 01 в памяти команд
- Процедуры хранятся в памяти последовательно, и вызов может быть выполнен из любой
  части программы. Подробнее - см. трансляция.
- Машинная команда может использоваться как с аргументами (адрес/значение), так и без них.
- Ввиду специфики варианта, числовые и строковые литералы записываются в память данных в
  момент исполнения программы, а не при запуске модели с помощью команд с Immediate Value.
  Формирование команд для записи строковых литералов -- на этапе трансляции
* Все переменные хранятся статически в памяти данных
* Используется стек данных и стек возврата, они являются отдельным физическим устройством
  по отношению к памяти данных и команд (см. модель процессора)


Память команд:  

Память команд представляет собой адресное пространство от 00 до 15000, где с 01 ячейки размещаются interrupt handler ы,
после чего идут уже обычные команды

```text

+-----------------------------+
| 00       jmp N              |
| 01       interrupt handle   |
|      ...                    |
| N - 1    interrupt handle   |
+-----------------------------+
| N        program            |
| N + 1    program            |
|      ...                    |
| 15000    program            |
+-----------------------------+
```

Память данных 

```text
+-----------------------------+
| 00       string literals    |  |
| 01       string literals    |  |
|      ...                    |  v
| 511      strings literal    |  
+-----------------------------+
| 512      variables          |  |
| 513      variables          |  |
|      ...                    |  v
| 15000    variables          |  
+-----------------------------+

```

Используется битовое кодирование команд, где первые 5 бит отвечают за opcode, следующие 15 бит за адрес в памяти и
остальные 12 отвечают за аргумент. То есть слово - 32 бита


## Система команд

### Цикл исполнения команды

1. Выборка инструкции (без сохранения информации в промежуточные регистры)
2. Исполнение команды (количество тактов необходимых для исполнения указано в таблице ниже)
3. Проверка на прерывание (если прерывание, сохранение PC в Return Stack, переход к обработчику прерывания)

### Набор инструкций

Большинство инструкций языка в явном виде соответствуют машинным командам, в таблице ниже
приведены все элементы системы команд ([isa.py](isa.py)). Те машинные команды, которые без комментария --
соответствуют слову из языка программирования. Спецификация количества тактов и последовательность
действий -- в разделе "Модель процессора".

| Инструкция | Комментарий                                                            |
|:-----------|:-----------------------------------------------------------------------|
| mul        |                                                                        |
| div        |                                                                        |
| sub        |                                                                        |
| add        |                                                                        |
| mod        |                                                                        |
| eq         |                                                                        |
| gr         |                                                                        |
| ls         |                                                                        |
| drop       |                                                                        |
| swap       |                                                                        |
| over       |                                                                        |
| dup        |                                                                        |
| ei         | разрешить прерывания                                                   |
| di         | запретить прерывания                                                   |
| omit       |                                                                        |
| read       |                                                                        |
| store      | память данных из стека                                                 |
| load       | в стек из памяти данных                                                |
| push imm   | записать в стек непосредственное значение                              |
| pop        | перенести значение со стека данных в стек возврата                     |
| rpop       | перенести значение из стека возврата в стек данных                     |
| jmp addr   | перейти по адресу                                                      |
| zjmp addr  | перейти по адресу, если на вершине стека 0 (убирает значение со стека) |
| call addr  | вызов процедуры                                                        |
| ret        | выход из процедуры или прерывания                                      |
| halt       | завершение программы                                                   |

### Кодирование инструкций

Инструкции кодируются в формат JSON и имеют вид:

```json
 {
  "index": 165,
  "command": "push",
  "arg": 554
}
```

В данной конструкции аргумент опционален и может быть упущен в зависимости от типа команды.

## Транслятор

Интерфейс командной строки `translator.py <input_file> <target_file>`

Реализован в модуле [translator.py](translator.py).

Основные сущностные элементы используемые в процессе трансляции:

* слово -- исходное слово в тексте программы (разделены пробелами)
* терм (Term ([translator.py:Term](translator.py#L9))) -- слово программы, преобразованное в формат машинной команды (
  слово != терм только для литералов)
* машинное слово (Opcode ([isa.py:Opcode](isa.py#L57))) -- непосредственно машинная команда

Трансляция происходит в несколько этапов ([translator.py:translate](translator.py#L357)):

1. Разбиение исходного текста программы в набор термов (1 слово = 1 терм)
2. Валидация полученных термов (циклы, процедуры, условные операторы)
3. Трансляция термов в машинные команды (1 терм = N команд)
4. Линковка

### Разбиение текста программы в набор термов

Так как текст программы представляет собой набор слов, разделенных пробелами
или переносом строки, процесс перевода слов в набор термов тривиален.

Реализуется функцией [translator.py:split_to_terms](translator.py#L61).

### Валидация полученных термов

Корректная программа на языке Forth должна удовлетворять формальным условиям, описанных в разделе "Язык
программирования".
Менее формально:

* терму `DO` должен соответствовать последующий терм `LOOP`
* терму `BEGIN` должен соответствовать последующий терм `UNTIL`
* терму `IF` должен соответствовать последующий терм `THEN`, между ними может располагаться терм `ELSE`
* терму `:` должен соответствовать последующий терм `;`
* терму `:intr` должен соответствовать последующий терм `;`
* объявление переменной должно иметь вид `variable <name> [allot <int>]`

Таким образом, на данном этапе проводится валидация термов, их дополнение необходимой мета-информацией
и оповещение пользователя в случае неуспешной трансляции с указанием ошибки и номера слова с ошибкой.

Реализуется функцией [translator.py:validate_and_fix_terms](translator.py#L174).

### Трансляция термов в машинные команды

Одному терму может соответствовать несколько Opcode, следовательно, необходимо корректным образом
с эффективностью по времени преобразовать термы в последовательность машинных команд.
В терминах языка Python применяются следующие трансформации:

```text
  list[Term] -> list[list[Opcode]] -> list[Opcode]
```

Первые два списка имеют одинаковую длину, во втором преобразовании происходит "распрямление"
полученного списка списков машинных команд.

Правила трансляции Term в Opcode с комментарием преобразований на стеке
определены в функции [translator.py:term_to_opcodes](translator.py#L227).

### Линковка

На этапе валидации каждому терму `IF`, `DO`, `:`, `ELSE` ставится в соответствие дополняющий его терм.
Подобная процедура выполняется также для `variable`, `allot`.

Таким образом, получается список операций, некоторые из которых могут ссылаться на другие.

Для преобразования этой структуры в последовательный список термов необходимо провести их
линковку, т.е. заменить адреса на термы адресами на машинные команды. Для этого используются различные
варианты адресации внутри машинных команд (абсолютная -- на конкретный терм и относительная -- по отношению к текущему
терму).
Реализуется функцией [translator.py:fix_addresses_in_opcodes](translator.py#L306).

Стоит заострить внимание на процессе трансляции строковых литералов и операторов DO, LOOP, i.
Данные инструкции трансформируются в несколько команд и некоторые из них затрагивают стек возврата.
Перед выполнением данных команд выставляется флаг на запрет прерываний, после выполнения -- снимается.

Остановимся подробнее на строковых литералах.
Так как целочисленные литералы преобразуются в машинную команду `PUSH <int>`, было
решено применить ради простоты модели процессора подобный механизм и для строк.
Строковые литералы в языке Forth используются сразу для вывода их на внешние устройства,
следовательно, строковый литерал вида `." string"` будет развернут в последовательность команд,
выполняющие следующие действия:

* запись в память данных размера строки (prefix-strings)
* посимвольная запись содержимого строки в память данных
* цикл, который осуществляет вывод строки

Данная последовательность команд может быть сокращена просто до вывода строки на внешнее
устройство, но имеет такой вид ввиду формальных критериев к лабораторной работе относительно
хранения строк в памяти.

## Модель процессора

Интерфейс командной строки: `machine.py <machine_code_file> <input_file>`

Реализовано в модуле: [machine.py](machine.py).

Stack Controller:
```text
                                        ----------------------------------------------------------------------
                                       |                                                                     |
                                  ------------                                                               |
                                 |            |                                                              |
                                 |     ALU    |                                                              |
                                 |            |                                                              |
                                  ------------                                                               |
 data_wr --------------            |                                                                         |
         |            |            |                                                                         |
SP------>|            |            |    ---------------------------------------------------------------      |
         |    Data    |            |   |                                                              |      |
         |    Stack   |            |   |                                                              |      |
         |            |  latch     --------      latch        --------       latch        --------    |      |
    -----|            |  next     |        |      temp       |        |       top        |        |   |      |
   |     --------------   ________|  NEXT  |-----       -----|  TEMP  |-----        -----|  TOP   |---|----  |
   |            ^         |       |        |    |       |    |        |    |        |    |        |   |   |  |
   |            |_________|        --------     |       |     --------     |        |     --------    |   |  |
   |                                   ^        |       |         ^        |        |         ^       |   |  |
   |                                   |        |       |         |        |        |         |       |   |  |
   |                              ------------  |       |    ------------  |        |    ------------ |   |  |
   |                             |     MUX    | |       |   |     MUX    | |        |   |    MUX     ||   |  |
   |                              ------------  |       |    ------------  |        |    ------------ |   |  |
   |                               ^    ^   ^   |       |     ^    ^    ^  |        |     ^    ^    ^ |   |  |
   |                               |    |   |   |       |     |    |    |  |        |     |    |    |__   |  |
   |_______________________________|    |   -------------     |    |    -------------     |    |          |  |
                                        |       |             |    |       |              |    -----------|---
                                        |       ---------------    |        --------------                |
                                         --------------------------|--------------------------------------
                                                                   |
                                                                   |
                                                                return_in


```


DataPath:
```text

                                  ------------------------------------------------
                                 |                                               |
                                 |  -----------------------------------------    |
                                 |  |                                        |   |       
                                 v  v                                        |   |
     -------                 -----------                                     |   |
--->|       |-->SP--------->|    TOS    |-------------------------------     |   |
| ->|  MUX  |       |       |           |--------------------          |     |   |
| |  -------        |       |-----------|                   |          |     |   |
| |                 |       |           |                   |          |     |   |
| |      +1         |       |   Data    |                   v          v     |   return_in
| ------------------|   ----|   Stack   |                  --------------    |   |
|        -1         |  |    |           |                 |     ALU      |   |   |
 -------------------   |   -|           |                  --------------    |   |
                   top |  |  -----------                          |          |   |
  --------------       |  |      ^  |                              ----------    |
 |         addr |<-----   |      |  |      --------                              |       
 |              |         |     top |  -->|  MUX   |              ------------   |
 |         val  |<-next---|      |  | | ->|        |--->I------->|    Return  |  |
 |              |                |  | ||   --------    +1  |     |    Stack   |--------->addr_ret
 |  Data memory |-----------------  | | -------------------|      ------------
  --------------                    | |        -1          |            ^
       mem_wr                       | |--------------------             |
                                    |                               -----------
                                    |                              |    MUX    |
                                    |                               -----------
                                    |                               ^         ^
                                    |                               |         |
                                     --return_out--------------------         PC


```

ControlUnit:
```text
     -------              ------------        ---------------                   -------
--->|  MUX  |            |            |      |               |<-----intr_req---|       |
| ->|       |-->PC------>| Instruction|----->| Instruction   |                 |       |
| |  -------        |    | Memory     |      | Decoder       |--intr_state---->|  PS   |
| |         +1      |    |            |      |               |--intr_mode----->|       |
| -------------------     ------------        ---------------                   -------
|                                               |       |
|                                         instr |       | signals
|                                               v       |
|                                      ----------------------
|                                     |                      |
--------------------------------------|       Data Path      |
                                      |                      |
                                       ----------------------


```

DataPath реализован в классе [machine.py:DataPath](machine.py#L118).

ControlUnit реализован в классе [machine.py:ControlUnit](machine.py#L233). .

Stack Controller является частью DataPath и предназначен для упрощения схемы, в коде включен в
класс [machine.py:DataPath](machine.py#L118).

Память:

* `Data Memory` -- однопортовая память данных
* `Instruction Memory` -- однопортовая память команд (Read Only)
* `Data Stack` -- стек для хранения данных программы (доступен программисту)
* `Return Stack` -- стек для хранения адресов возврата и переменной цикла

В модели процессора предусмотрены следующие регистры (недоступны для программиста):

* `SP` -- адрес верхушки стека данных минус два верхних элемента
* `I` -- адрес верхушки стека возврата
* `PC` -- адрес указывающий на текущую исполняемую команду
* `PS` -- состояние программы, 3 бита: разрешены ли прерывания и есть ли запрос на прерывания, находится ли в прерывании
* `TOP` -- значение на верхушке стека
* `NEXT` -- значение второго элемента сверху на стеке
* `TEMP` -- предназначен для эффективного выполнения операций на стеке

В рамках текущей реализации процессора приведем более подробную таблицу с описанием реализуемой системы команд.

| Инструкция                          | Действия процессора                                                   | Количество тактов |
|:------------------------------------|:----------------------------------------------------------------------|-------------------|
| mul, div, sub, add, mod, eq, gr, ls | TOP = TOP x NEXT; SP -= 1; NEXT = MEM                                 | 3                 |
| drop                                | TOP = NEXT; SP -= 1; NEXT = MEM                                       | 2                 |
| swap                                | TEMP = TOP; TOP = NEXT; NEXT = TEMP                                   | 3                 |
| over                                | MEM = NEXT; TEMP = TOP; SP += 1; TOP = NEXT; NEXT = TEMP              | 4                 |
| dup                                 | MEM = NEXT; NEXT = TOP; SP += 1                                       | 2                 |
| store                               | DATA_MEM = NEXT; SP -= 1; NEXT = MEM; TOP = NEXT; SP -= 1; NEXT = MEM | 4                 |
| load                                | TOP = DATA_MEM                                                        | 1                 |
| push                                | MEM = NEXT; SP += 1; NEXT = TOP; TOP = IMMEDIATE                      | 3                 |
| pop                                 | TEMP = TOP; TOP = NEXT; SP -= 1; NEXT = MEM; RET_STACK = TEMP; I += 1 | 4                 |
| rpop                                | I -= 1; TEMP = RET_STACK; MEM = NEXT; NEXT = TOP; SP += 1; TOP = TEMP | 4                 |
| jmp                                 | PC = IMMEDIATE                                                        | 1                 |
| zjmp                                | PC = IMMEDIATE; TOP = NEXT; SP -= 1; NEXT = MEM                       | 2                 |
| call                                | RETURN_STACK = PC; I += 1; PC = IMMEDIATE                             | 2                 |
| ret                                 | I -= 1; PC = RET_STACK                                                | 2                 |

Действия процессора в данной таблице в явном виде описывают последовательность сигналов, которые
выставляет дешифратор команд. В таблице не отражен тот факт, что команды могут исполняться за меньшее
количество тактов, нежели необходимо действий процессора, т.к. некоторые последовательные действия независимы
и могут быть выполнены за один такт.

Подробную реализацию дешифрации команд можно найти в
методе [ControlUnit:decode_and_execute_instruction](machine.py#L436).





### Цикл исполнения команды

1. Выборка инструкции (без сохранения информации в промежуточные регистры)
2. Исполнение команды (количество тактов необходимых для исполнения указано в таблице ниже)
3. Проверка на прерывание (если прерывание, сохранение PC в Return Stack, переход к обработчику прерывания)


```text
| ФИО                            | алг     | LoC | code байт | code инстр. | инстр. | такт. | вариант                                                                         |
| Шипулин Олег Игоревич          | alice   |
| Шипулин Олег Игоревич          | cat     |
| Шипулин Олег Игоревич          | hello   |
| Шипулин Олег Игоревич          | prob5   |
```
